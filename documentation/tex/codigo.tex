\section{Análisis de Código}

\subsection{Funcionalidades Implementadas y Análisis del Código}

El trabajo implementa un motor lógico similar a Prolog, que permite definir una base de conocimientos con hechos y reglas, y luego realizar consultas para verificar si algo es verdadero o falso según esa base.  
También soporta variables libres, por lo que puede encontrar valores que hagan cierta una proposición.  

El programa se ejecuta por consola y recibe dos archivos como argumentos: uno con la base de conocimientos (en formato \texttt{.pl}) y otro con las consultas a evaluar.  
Cada línea del archivo de consultas produce una línea de salida, que puede ser simplemente \texttt{true} o \texttt{false}, o bien \texttt{true (X = valor)} cuando hay variables que se unifican.  

El desarrollo se dividió en varios módulos para mantener una estructura clara:
\begin{itemize}
  \item \textbf{Clases}: definen las estructuras principales del lenguaje lógico.
  \item \textbf{Parser}: se encarga de leer los archivos y transformarlos en objetos del programa.
  \item \textbf{Engine}: resuelve las consultas mediante unificación, sustituciones y backtracking.
  \item \textbf{Main}: gestiona la ejecución general, lee los archivos y muestra los resultados.
\end{itemize}

\subsection{Partes del Código}

\subsubsection{Clases}

En este módulo se definieron las entidades básicas del lenguaje:
\begin{itemize}
  \item \texttt{Atomo}: representa una constante o símbolo, como por ejemplo \texttt{juan} o \texttt{auto}.
  \item \texttt{Variable}: representa variables libres o ligadas, que se escriben con mayúscula, como \texttt{X} o \texttt{Y}.
  \item \texttt{Predicado}: combina un nombre con una lista de expresiones, por ejemplo \texttt{padre(juan, maria)}.
  \item \texttt{Hecho}: representa un predicado simple, sin condiciones.
  \item \texttt{Regla}: representa una cláusula de Horn con cabeza y cuerpo, por ejemplo \texttt{abuelo(X,Y) :- padre(X,Z), padre(Z,Y)}.
\end{itemize}

Estas estructuras reflejan la forma en que Prolog interpreta la información, pero adaptadas a un modelo funcional en Scala.  
Todas son inmutables, lo que evita efectos secundarios y mantiene el código más claro.

\subsubsection{Parser}

El \texttt{Parser} es el encargado de leer las líneas de los archivos y convertirlas en objetos de tipo \texttt{Conocimiento}.  
Su funcionamiento se basa en reconocer la estructura de las sentencias y crear las instancias correspondientes.  
Las funciones más importantes son:

\begin{itemize}
  \item \textbf{parseExpresion}: identifica si el token leído es un átomo, una variable o un predicado.
  \item \textbf{parsePredicado}: separa el nombre y los argumentos, teniendo en cuenta los paréntesis y las comas.
  \item \textbf{parseHecho} y \textbf{parseRule}: crean los objetos \texttt{Hecho} y \texttt{Regla} a partir de texto.
  \item \textbf{parseLines}: recibe una lista de líneas y devuelve una lista con todos los conocimientos válidos.
\end{itemize}

Además, se implementó una función auxiliar para dividir correctamente los argumentos separados por comas sin confundirse con los que están dentro de paréntesis.  
Esto es clave para que el parseo funcione bien incluso con reglas más complejas.

\subsubsection{Engine / Unificación}

El \texttt{Engine} es el corazón del programa.  
Aquí se resuelven las consultas aplicando el algoritmo de unificación, las sustituciones necesarias y el mecanismo de backtracking.

Algunas de las funciones más importantes son:

\begin{itemize}
  \item \textbf{aplicarSustitucion}: reemplaza las variables por los valores que fueron ligados en una sustitución.
  \item \textbf{extraerVariables}: obtiene las variables libres que aparecen en una consulta.
  \item \textbf{standardizeApart}: renombra variables internas de una regla para evitar conflictos cuando se aplican varias veces.
  \item \textbf{evaluarBuiltIn}: maneja operaciones especiales como \texttt{suma/3}, \texttt{resta/3}, \texttt{multiplicacion/3}, \texttt{eq/2}, \texttt{neq/2} y \texttt{gt/2}.  
  Estas operaciones se resuelven directamente en el motor, sin buscar en la base de conocimiento.
  \item \textbf{resolverMeta} y \textbf{resolverCuerpo}: implementan la lógica de resolución.  
  Buscan hechos o reglas que unifiquen con la meta actual, aplican las sustituciones y continúan con las metas siguientes.  
  Si falla una unificación, se retrocede (backtracking) y se prueba otra opción.
  \item \textbf{formatResultado}: prepara la salida final, mostrando las variables y los valores que las satisfacen.
\end{itemize}

La unificación se implementó de forma recursiva.  
Si ambas expresiones son iguales, no hace nada; si una es variable, la liga con la otra;  
si ambas son predicados con igual nombre y cantidad de argumentos, intenta unificarlos uno por uno.  
Si no coincide la estructura, la unificación falla.